package completioncmd

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/pubgo/redant"
)

// CompletionCommand is a built-in command for generating shell completion scripts
var CompletionCommand = redant.Command{
	Use:   "completion [shell]",
	Short: "Generate the autocompletion script for the specified shell",
	Long: `Generate the autocompletion script for redant for the specified shell.
See each sub-command's help for details on how to use the generated script.`,
	Handler: func(ctx context.Context, inv *redant.Invocation) error {
		if len(inv.Args) == 0 {
			fmt.Fprintf(inv.Stderr, "error: shell argument is required. Available shells: bash, zsh, fish\n")
			return fmt.Errorf("missing shell argument")
		}

		shell := inv.Args[0]
		switch shell {
		case "bash":
			return generateBashCompletion(ctx, inv)
		case "zsh":
			return generateZshCompletion(ctx, inv)
		case "fish":
			return generateFishCompletion(ctx, inv)
		default:
			fmt.Fprintf(inv.Stderr, "error: unsupported shell: %s. Available shells: bash, zsh, fish\n", shell)
			return fmt.Errorf("unsupported shell: %s", shell)
		}
	},
}

// generateBashCompletion generates bash completion script
func generateBashCompletion(ctx context.Context, inv *redant.Invocation) error {
	cmd := inv.Command.Parent() // Get the root command
	if cmd == nil {
		cmd = inv.Command
	}

	progName := filepath.Base(os.Args[0])

	// Header
	header := fmt.Sprintf(`#!/bin/bash

# %s completion for bash
# Autogenerated by redant

%s() {
    local cur prev opts cmd
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Command stack tracking
    local cmd_stack=()
    local i=1
    local found_cmd=false

    # Build command stack
    while [ $i -lt $COMP_CWORD ]; do
        cmd="${COMP_WORDS[$i]}"
        cmd_stack+=($cmd)
        i=$((i+1))
    done

    # Handle completion based on command stack
    case "${cmd_stack[@]}" in
`, progName, progName)

	// Generate command completions
	var commandsBuf bytes.Buffer
	generateBashCommandCompletions(cmd, "", &commandsBuf, progName)

	// Footer
	footer := fmt.Sprintf(`    *)
        COMPREPLY=()
        ;;
    esac
}

complete -F %s %s
`, progName, progName)

	// Write the full script
	fmt.Fprint(inv.Stdout, header)
	commandsBuf.WriteTo(inv.Stdout)
	fmt.Fprint(inv.Stdout, footer)

	return nil
}

// generateBashCommandCompletions generates command completion for bash recursively
func generateBashCommandCompletions(cmd *redant.Command, indent string, buf *bytes.Buffer, progName string) {
	cmdName := cmd.Name()
	fullName := cmd.FullName()

	// Generate option completions for this command
	buf.WriteString(fmt.Sprintf(`    %q)
        # Completions for %s
        local opts="--help "
`, fullName, cmdName))

	// Add all options
	for _, opt := range cmd.FullOptions() {
		if opt.Hidden {
			continue
		}
		if opt.Flag != "" {
			buf.WriteString(fmt.Sprintf("        opts+='--%s '\n", opt.Flag))
			if opt.Shorthand != "" {
				buf.WriteString(fmt.Sprintf("        opts+='-%s '\n", opt.Shorthand))
			}
		}
	}

	// Add subcommands
	if len(cmd.Children) > 0 {
		buf.WriteString("        local subcmds=\"")
		for _, child := range cmd.Children {
			if !child.Hidden {
				buf.WriteString(fmt.Sprintf("%s ", child.Name()))
			}
		}
		buf.WriteString("\"\n")
		buf.WriteString("        COMPREPLY=( $(compgen -W \"$opts $subcmds\" -- \"$cur\") )")
	} else {
		buf.WriteString("        COMPREPLY=( $(compgen -W \"$opts\" -- \"$cur\") )")
	}

	buf.WriteString("\n        ;;")

	// Generate completions for subcommands
	for _, child := range cmd.Children {
		if !child.Hidden {
			generateBashCommandCompletions(child, indent+"    ", buf, progName)
		}
	}
}

// generateZshCompletion generates zsh completion script
func generateZshCompletion(ctx context.Context, inv *redant.Invocation) error {
	cmd := inv.Command.Parent() // Get the root command
	if cmd == nil {
		cmd = inv.Command
	}

	progName := filepath.Base(os.Args[0])

	// Header
	header := fmt.Sprintf(`#compdef %s

# %s completion for zsh
# Autogenerated by redant

%s() {
    local context state line
    typeset -A opt_args

    _arguments -C \
`, progName, progName, progName)

	// Generate command completions
	var commandsBuf bytes.Buffer
	generateZshCommandCompletions(cmd, &commandsBuf)

	// Footer
	footer := fmt.Sprintf(`)}

%s
`, progName)

	// Write the full script
	fmt.Fprint(inv.Stdout, header)
	commandsBuf.WriteTo(inv.Stdout)
	fmt.Fprint(inv.Stdout, footer)

	return nil
}

// generateZshCommandCompletions generates command completion for zsh recursively
func generateZshCommandCompletions(cmd *redant.Command, buf *bytes.Buffer) {
	cmdName := cmd.Name()
	fullName := cmd.FullName()

	// Generate command entry
	if fullName == cmdName { // Root command
		buf.WriteString(fmt.Sprintf("    '::subcommands:(%s)'", getZshSubcommands(cmd)))
	} else {
		// For subcommands, we need to add them to the appropriate context
		// This is a simplified version - full zsh completion would require more complex context management
	}

	// Add options
	for _, opt := range cmd.FullOptions() {
		if opt.Hidden {
			continue
		}

		var optDef string
		if opt.Shorthand != "" {
			optDef = fmt.Sprintf("'-%s[--%s]' '--%s[%s]'", opt.Shorthand, opt.Flag, opt.Flag, opt.Description)
		} else {
			optDef = fmt.Sprintf("'--%s[%s]'", opt.Flag, opt.Description)
		}

		buf.WriteString(fmt.Sprintf(" %s", optDef))
	}

	// Generate completions for subcommands
	for _, child := range cmd.Children {
		if !child.Hidden {
			buf.WriteString(" '1: :->subcmds'")
			break
		}
	}

	// Add subcommand handlers
	if len(cmd.Children) > 0 {
		buf.WriteString(`\ case $state in
        subcmds)
            local subcommands=(")
		for _, child := range cmd.Children {
			if !child.Hidden {
				buf.WriteString(fmt.Sprintf("'%s:%s' ", child.Name(), child.Short))
			}
		}
		buf.WriteString(")")
		buf.WriteString(" 
            _describe 'subcommands' subcommands
            ;;
    esac`)
	}
}

// getZshSubcommands returns a string of subcommands for zsh completion
func getZshSubcommands(cmd *redant.Command) string {
	var subcmds []string
	for _, child := range cmd.Children {
		if !child.Hidden {
			subcmds = append(subcmds, child.Name())
		}
	}
	sort.Strings(subcmds)
	return strings.Join(subcmds, " ")
}

// generateFishCompletion generates fish completion script
func generateFishCompletion(ctx context.Context, inv *redant.Invocation) error {
	cmd := inv.Command.Parent() // Get the root command
	if cmd == nil {
		cmd = inv.Command
	}

	progName := filepath.Base(os.Args[0])

	// Header
	header := fmt.Sprintf(`# %s completion for fish
# Autogenerated by redant

complete -c %s -n "__fish_use_subcommand" -a "completion" -d "Generate the autocompletion script for the specified shell"
`, progName, progName)

	// Generate command completions
	var commandsBuf bytes.Buffer
	generateFishCommandCompletions(cmd, &commandsBuf)

	// Write the full script
	fmt.Fprint(inv.Stdout, header)
	commandsBuf.WriteTo(inv.Stdout)

	return nil
}

// generateFishCommandCompletions generates command completion for fish recursively
func generateFishCommandCompletions(cmd *redant.Command, buf *bytes.Buffer) {
	cmdName := cmd.Name()
	fullCmdPath := cmd.FullName()
	cmdParts := strings.Split(fullCmdPath, " ")

	// Generate completions for this command's options
	for _, opt := range cmd.FullOptions() {
		if opt.Hidden {
			continue
		}

		var completeCmd string
		if len(cmdParts) > 1 {
			// Subcommand
			completeCmd = fmt.Sprintf("complete -c %s -n \"__fish_seen_subcommand_from %s\"", cmdParts[0], strings.Join(cmdParts[1:], " "))
		} else {
			// Root command
			completeCmd = fmt.Sprintf("complete -c %s", cmdName)
		}

		if opt.Shorthand != "" {
			completeCmd += fmt.Sprintf(" -s %s", opt.Shorthand)
		}

		completeCmd += fmt.Sprintf(" -l %s -d \"%s\"", opt.Flag, opt.Description)

		// Add value hint if applicable
		if opt.Type() != "bool" {
			completeCmd += fmt.Sprintf(" -r -f -a \"(__fish_complete_placeholder %s)\"", opt.Type())
		}

		buf.WriteString(completeCmd)
		buf.WriteString("\n")
	}

	// Generate completions for subcommands
	if len(cmd.Children) > 0 {
		var subcmds []string
		for _, child := range cmd.Children {
			if !child.Hidden {
				subcmds = append(subcmds, child.Name())
				buf.WriteString(fmt.Sprintf("complete -c %s -n \"__fish_seen_subcommand_from %s\" -a \"%s\" -d \"%s\"\n",
					cmdParts[0], strings.Join(cmdParts[1:], " "),
					child.Name(), child.Short))
			}
		}
	}

	// Recursively generate completions for subcommands
	for _, child := range cmd.Children {
		if !child.Hidden {
			generateFishCommandCompletions(child, buf)
		}
	}
}

// AddCompletionCommand adds the completion command to the root command
func AddCompletionCommand(rootCmd *redant.Command) {
	rootCmd.Children = append(rootCmd.Children, &CompletionCommand)
}
